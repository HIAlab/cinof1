##############################################################
# Bayesian Networks
# 4/4/2021
# created by T. GÃ¤rtner (thomas.gaertner@student.hpi.de)
##############################################################



#' Prepare Dag
#' @description This function reformat a DAG from DAGitty to bn.learn DAG
#' @param dag DAG in a DAGitty format
#' @return bnlearn graph based on DAGitty graph
#' @examples
#' load(simpatdag)
#' bn.prep.dag(simpatdag)
#' @export
bn.prep.dag <- function(dag){
  exposure <- exposures(dag)
  outcome <- outcomes(dag)
  names <- names(dag)
  bn.dag <- bnlearn::empty.graph(nodes = names(dag))
  edges <- edges(dag)
  edges$from <- edges$v
  edges$to <- edges$w
  edges[] <- lapply(edges,as.character)
  bnlearn::arcs(bn.dag) = edges[,c("from","to")]
  plot(bn.dag, main = "Transformed Bn DAG")
  return(list(dag = bn.dag, exposure = exposure, outcome = outcome, variables=names))
}


#' Bayesian Network Analysis
#' @description This function is an Interface to the fitting function for Bayesian Networks from bnlearn
#' @param dag DAG generated by
#' @param data R data frame to fit the Bayesian network
#' @param method Method used to analyze. Default is 'bayes'. Alternative is 'mle'
#' @return bn.fit object
#' @examples
#' load(simpatdag)
#' bn.prep.dag(simpatdag)
#' @export
bn.fit.dag <- function(data, dag, method = "bayes"){
  fit <- bnlearn::bn.fit(dag$dag, data, method = method)
  return(fit)
}


#' Preprocess data
#' @description This function preprocesses a dataframe to be used for bn.fit
#' @param dag result from bn.prep.dag
#' @param data R data frame to fit the Bayesian network
#' @param id column name of patient identifier (only needed when lag column)
#' @param time_col column name of time (integer expected, only needed when lag column)
#' @return data frame
#' @examples
#' load(simpatdag)
#' bn.prep.dag(simpatdag)
#' @export
bn.prep.data <- function(dag, data, id="patient_id", time_col="day"){
  # get relevant columns
  names <- dag$variables
  # calculate lag
  for(name in names){
    # test, if lag is included
    if(grepl(".lag_", name, fixed=TRUE)){
      # extract lag and col information
      res <- stringr::str_split(name, ".lag_", n = 2, simplify = TRUE)
      var_name <- res[1]
      lag <- as.numeric(res[2])
      # creat lag column
      data[,name] <- data[,var_name]
      for(row in c(1:nrow(data))){
        data_point <- data[data[,id] == data[row,id] & data[,time_col] == data[row,time_col]-lag,]
        if (!nrow(data_point)==0){
          data[row,name] <- data_point[1,var_name]
        }else{
          data[row,name] <- NA
        }
      }
      if(lapply(simpatdat, class)[[var_name]]=="factor"){
        data[,name] <- as.factor(data[,name])
        levels(data[,name]) <- levels(data[,var_name])
      }
    }
  }
  # filter column names
  data <- data[,names]
  # return dataframe
  return(data)
}

